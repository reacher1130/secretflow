{
  "name": "secretflow",
  "desc": "First-party SecretFlow components.",
  "version": "0.0.1",
  "comps": [
    {
      "domain": "data_filter",
      "name": "condition_filter",
      "desc": "Filter the table based on a single column's values and condition.\nWarning: the party responsible for condition filtering will directly send the sample distribution to other participants.\nMalicious participants can obtain the distribution of characteristics by repeatedly calling with different filtering values.\nAudit the usage of this component carefully.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "comparator",
          "desc": "Comparator to use for comparison. Must be one of '==','<','<=','>','>=','IN'",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "==",
                "<",
                "<=",
                ">",
                ">=",
                "IN"
              ]
            }
          }
        },
        {
          "name": "value_type",
          "desc": "Type of the value to compare with. Must be one of ['STRING', 'FLOAT']",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "STRING",
                "FLOAT"
              ]
            }
          }
        },
        {
          "name": "bound_value",
          "desc": "Input a str with values separated by ','. List of values to compare with. If comparator is not 'IN', we only support one element in this list.",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "float_epsilon",
          "desc": "Epsilon value for floating point comparison. WARNING: due to floating point representation in computers, set this number slightly larger if you want filter out the values exactly at desired boundary. for example, abs(1.001 - 1.002) is slightly larger than 0.001, and therefore may not be filter out using == and epsilson = 0.001",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1e-06
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "features",
              "desc": "Feature(s) to operate on.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "out_ds",
          "desc": "Output vertical table that satisfies the condition.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_ds_else",
          "desc": "Output vertical table that does not satisfies the condition.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "data_filter",
      "name": "expr_condition_filter",
      "desc": "Only row-level filtering is supported, column processing is not available;\nthe custom expression must comply with SQLite syntax standards",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "expr",
          "desc": "The custom expression must comply with SQLite syntax standards",
          "type": "AT_STRING",
          "atomic": {}
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input vertical or individual table",
          "types": [
            "sf.table.individual",
            "sf.table.vertical_table"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out_ds",
          "desc": "Output table that satisfies the condition",
          "types": [
            "sf.table.individual",
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_ds_else",
          "desc": "Output table that does not satisfies the condition",
          "types": [
            "sf.table.individual",
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "data_filter",
      "name": "feature_filter",
      "desc": "Drop features from the dataset.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "drop_features",
              "desc": "Features to drop."
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "out_ds",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "data_filter",
      "name": "sample",
      "desc": "Sample data set.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "sample_algorithm",
          "desc": "sample algorithm and parameters",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "random"
          }
        },
        {
          "prefixes": [
            "sample_algorithm"
          ],
          "name": "random",
          "desc": "Random sample.",
          "type": "AT_STRUCT_GROUP"
        },
        {
          "prefixes": [
            "sample_algorithm",
            "random"
          ],
          "name": "frac",
          "desc": "Proportion of the dataset to sample in the set. The fraction should be larger than 0.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.8
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            }
          }
        },
        {
          "prefixes": [
            "sample_algorithm",
            "random"
          ],
          "name": "random_state",
          "desc": "Specify the random seed of the shuffling.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "prefixes": [
            "sample_algorithm",
            "random"
          ],
          "name": "replacement",
          "desc": "If true, sampling with replacement. If false, sampling without replacement.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "prefixes": [
            "sample_algorithm"
          ],
          "name": "system",
          "desc": "system sample.",
          "type": "AT_STRUCT_GROUP"
        },
        {
          "prefixes": [
            "sample_algorithm",
            "system"
          ],
          "name": "frac",
          "desc": "Proportion of the dataset to sample in the set. The fraction should be larger than 0 and less than or equal to 0.5.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.2
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 0.5
            },
            "upperBoundInclusive": true
          }
        },
        {
          "prefixes": [
            "sample_algorithm"
          ],
          "name": "stratify",
          "desc": "stratify sample.",
          "type": "AT_STRUCT_GROUP"
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "frac",
          "desc": "Proportion of the dataset to sample in the set. The fraction should be larger than 0.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.8
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            }
          }
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "random_state",
          "desc": "Specify the random seed of the shuffling.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "observe_feature",
          "desc": "stratify sample observe feature.",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "replacements",
          "desc": "If true, sampling with replacement. If false, sampling without replacement.",
          "type": "AT_BOOLS",
          "atomic": {
            "listMaxLengthInclusive": "-1"
          }
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "quantiles",
          "desc": "stratify sample quantiles",
          "type": "AT_FLOATS",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1000"
          }
        },
        {
          "prefixes": [
            "sample_algorithm",
            "stratify"
          ],
          "name": "weights",
          "desc": "stratify sample weights",
          "type": "AT_FLOATS",
          "atomic": {
            "listMaxLengthInclusive": "-1",
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ]
        }
      ],
      "outputs": [
        {
          "name": "sample_output",
          "desc": "Output sampled dataset.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ]
        },
        {
          "name": "reports",
          "desc": "Output sample reports",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "data_prep",
      "name": "psi",
      "desc": "PSI between two parties.",
      "version": "0.0.5",
      "attrs": [
        {
          "name": "protocol",
          "desc": "PSI protocol.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "PROTOCOL_RR22"
            },
            "allowedValues": {
              "ss": [
                "PROTOCOL_RR22",
                "PROTOCOL_ECDH",
                "PROTOCOL_KKRT"
              ]
            }
          }
        },
        {
          "name": "sort_result",
          "desc": "It false, output is not promised to be aligned. Warning: disable this option may lead to errors in the following components. DO NOT TURN OFF if you want to append other components.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        },
        {
          "name": "allow_duplicate_keys",
          "desc": "Some join types allow duplicate keys.",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "no"
          }
        },
        {
          "prefixes": [
            "allow_duplicate_keys"
          ],
          "name": "no",
          "desc": "Duplicate keys are not allowed.",
          "type": "AT_STRUCT_GROUP"
        },
        {
          "prefixes": [
            "allow_duplicate_keys",
            "no"
          ],
          "name": "skip_duplicates_check",
          "desc": "If true, the check of duplicated items will be skiped.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "prefixes": [
            "allow_duplicate_keys",
            "no"
          ],
          "name": "check_hash_digest",
          "desc": "Check if hash digest of keys from parties are equal to determine whether to early-stop.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "prefixes": [
            "allow_duplicate_keys"
          ],
          "name": "yes",
          "desc": "Duplicate keys are allowed.",
          "type": "AT_STRUCT_GROUP"
        },
        {
          "prefixes": [
            "allow_duplicate_keys",
            "yes"
          ],
          "name": "join_type",
          "desc": "Join type.",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "inner_join"
          }
        },
        {
          "prefixes": [
            "allow_duplicate_keys",
            "yes",
            "join_type"
          ],
          "name": "inner_join",
          "desc": "Inner join with duplicate keys"
        },
        {
          "prefixes": [
            "allow_duplicate_keys",
            "yes",
            "join_type"
          ],
          "name": "left_join",
          "desc": "Left join with duplicate keys",
          "type": "AT_STRUCT_GROUP"
        },
        {
          "prefixes": [
            "allow_duplicate_keys",
            "yes",
            "join_type",
            "left_join"
          ],
          "name": "left_side",
          "desc": "Required for left join",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          }
        },
        {
          "prefixes": [
            "allow_duplicate_keys",
            "yes",
            "join_type"
          ],
          "name": "full_join",
          "desc": "Full join with duplicate keys"
        },
        {
          "prefixes": [
            "allow_duplicate_keys",
            "yes",
            "join_type"
          ],
          "name": "difference",
          "desc": "Difference with duplicate keys"
        },
        {
          "name": "fill_value_int",
          "desc": "For int type data. Use this value for filling null.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "ecdh_curve",
          "desc": "Curve type for ECDH PSI.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "CURVE_FOURQ"
            },
            "allowedValues": {
              "ss": [
                "CURVE_25519",
                "CURVE_FOURQ",
                "CURVE_SM2",
                "CURVE_SECP256K1"
              ]
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "receiver_input",
          "desc": "Individual table for receiver",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "key",
              "desc": "Column(s) used to join.",
              "colMinCntInclusive": "1"
            }
          ]
        },
        {
          "name": "sender_input",
          "desc": "Individual table for sender",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "key",
              "desc": "Column(s) used to join.",
              "colMinCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "psi_output",
          "desc": "Output vertical table",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "data_prep",
      "name": "train_test_split",
      "desc": "Split datasets into random train and test subsets.\n- Please check: https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "train_size",
          "desc": "Proportion of the dataset to include in the train subset. The sum of test_size and train_size should be in the (0, 1] range.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.75
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "test_size",
          "desc": "Proportion of the dataset to include in the test subset. The sum of test_size and train_size should be in the (0, 1] range.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.25
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "random_state",
          "desc": "Specify the random seed of the shuffling.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "shuffle",
          "desc": "Whether to shuffle the data before splitting.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ],
      "outputs": [
        {
          "name": "train",
          "desc": "Output train dataset.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "test",
          "desc": "Output test dataset.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "data_prep",
      "name": "union",
      "desc": "Perform a horizontal merge of two data tables, supporting the individual table or vertical table on the same node.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input1",
          "desc": "The first input table",
          "types": [
            "sf.table.individual",
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "input2",
          "desc": "The second input table",
          "types": [
            "sf.table.individual",
            "sf.table.vertical_table"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "Output table",
          "types": [
            "sf.table.individual",
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "feature",
      "name": "vert_binning",
      "desc": "Generate equal frequency or equal range binning rules for vertical partitioning datasets.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "binning_method",
          "desc": "How to bin features with numeric types: \"quantile\"(equal frequency)/\"eq_range\"(equal range)",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "eq_range"
            },
            "allowedValues": {
              "ss": [
                "eq_range",
                "quantile"
              ]
            }
          }
        },
        {
          "name": "bin_num",
          "desc": "Max bin counts for one features.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "report_rules",
          "desc": "Whether report binning rules.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be binned.",
              "colMinCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "bin_rule",
          "desc": "Output bin rule.",
          "types": [
            "sf.rule.binning"
          ]
        },
        {
          "name": "report",
          "desc": "report rules details if report_rules is true",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "feature",
      "name": "vert_woe_binning",
      "desc": "Generate Weight of Evidence (WOE) binning rules for vertical partitioning datasets.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "secure_device_type",
          "desc": "Use SPU(Secure multi-party computation or MPC) or HEU(Homomorphic encryption or HE) to secure bucket summation.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "spu"
            },
            "allowedValues": {
              "ss": [
                "spu",
                "heu"
              ]
            }
          }
        },
        {
          "name": "binning_method",
          "desc": "How to bin features with numeric types: \"quantile\"(equal frequency)/\"chimerge\"(ChiMerge from AAAI92-019: https://www.aaai.org/Papers/AAAI/1992/AAAI92-019.pdf)/\"eq_range\"(equal range)",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "quantile"
            },
            "allowedValues": {
              "ss": [
                "quantile",
                "chimerge",
                "eq_range"
              ]
            }
          }
        },
        {
          "name": "bin_num",
          "desc": "Max bin counts for one features.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "positive_label",
          "desc": "Which value represent positive value in label.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "1"
            }
          }
        },
        {
          "name": "chimerge_init_bins",
          "desc": "Max bin counts for initialization binning in ChiMerge.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "100"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            }
          }
        },
        {
          "name": "chimerge_target_bins",
          "desc": "Stop merging if remaining bin counts is less than or equal to this value.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "chimerge_target_pvalue",
          "desc": "Stop merging if biggest pvalue of remaining bins is greater than this value.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "report_rules",
          "desc": "Whether report binning rules.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be binned. WARNING: WOE won't be effective for features with enumeration count <=2.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of input data.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "bin_rule",
          "desc": "Output WOE rule.",
          "types": [
            "sf.rule.binning"
          ]
        },
        {
          "name": "report",
          "desc": "report rules details if report_rules is true",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "io",
      "name": "identity",
      "desc": "map any input to output",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input data",
          "types": [
            "sf.model.ss_glm",
            "sf.model.sgb",
            "sf.model.ss_xgb",
            "sf.model.ss_sgd",
            "sf.rule.binning",
            "sf.rule.preprocessing",
            "sf.read_data"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_data",
          "desc": "Output data",
          "types": [
            "sf.model.ss_glm",
            "sf.model.sgb",
            "sf.model.ss_xgb",
            "sf.model.ss_sgd",
            "sf.rule.binning",
            "sf.rule.preprocessing",
            "sf.read_data"
          ]
        }
      ]
    },
    {
      "domain": "io",
      "name": "read_data",
      "desc": "read model or rules from sf cluster",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_dd",
          "desc": "Input dist data",
          "types": [
            "sf.rule.binning",
            "sf.model.ss_glm"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_data",
          "desc": "Output rules or models in DistData.meta",
          "types": [
            "sf.read_data"
          ]
        }
      ]
    },
    {
      "domain": "io",
      "name": "write_data",
      "desc": "write model or rules back to sf cluster",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "write_data",
          "desc": "rule or model protobuf by json format",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "write_data_type",
          "desc": "which rule or model is writing",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "sf.rule.binning"
            },
            "allowedValues": {
              "ss": [
                "sf.rule.binning",
                "sf.model.ss_glm"
              ]
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "input_dd",
          "desc": "Input dist data. Rule reconstructions may need hidden info in original rule for security considerations.",
          "types": [
            "sf.rule.binning",
            "sf.model.ss_glm"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output rules or models in sf cluster format",
          "types": [
            "sf.rule.binning",
            "sf.model.ss_glm"
          ]
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "biclassification_eval",
      "desc": "Statistics evaluation for a bi-classification model on a dataset.\n1. summary_report: SummaryReport\n2. eq_frequent_bin_report: List[EqBinReport]\n3. eq_range_bin_report: List[EqBinReport]\n4. head_report: List[PrReport]\nreports for fpr = 0.001, 0.005, 0.01, 0.05, 0.1, 0.2",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "bucket_size",
          "desc": "Number of buckets.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "min_item_cnt_per_bucket",
          "desc": "Min item cnt per bucket. If any bucket doesn't meet the requirement, error raises. For security reasons, we require this parameter to be at least 5.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "5"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "5"
            },
            "lowerBoundInclusive": true
          }
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input table with prediction and label, usually is a result from a prediction component.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "label",
              "desc": "The label name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "prediction",
              "desc": "The prediction result column name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "reports",
          "desc": "Output report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "prediction_bias_eval",
      "desc": "Calculate prediction bias, ie. average of predictions - average of labels.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "bucket_num",
          "desc": "Num of bucket.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "min_item_cnt_per_bucket",
          "desc": "Min item cnt per bucket. If any bucket doesn't meet the requirement, error raises. For security reasons, we require this parameter to be at least 2.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "2"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "2"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "bucket_method",
          "desc": "Bucket method.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "equal_width"
            },
            "allowedValues": {
              "ss": [
                "equal_width",
                "equal_frequency"
              ]
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input table with prediction and label, usually is a result from a prediction component.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "label",
              "desc": "The label name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "prediction",
              "desc": "The prediction result column name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "result",
          "desc": "Output report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "regression_eval",
      "desc": "Statistics evaluation for a regression model on a dataset.\nContained Statistics:\nR2 Score (r2_score): It is a statistical measure that represents the proportion of the variance in the dependent variable that can be predicted from the independent variables. It ranges from 0 to 1, where a higher value indicates a better fit.\nMean Absolute Error (mean_abs_err): It calculates the average absolute difference between the predicted and actual values. It provides a measure of the average magnitude of the errors.\nMean Absolute Percentage Error (mean_abs_percent_err): It calculates the average absolute percentage difference between the predicted and actual values. It measures the average magnitude of the errors in terms of percentages.\nSum of Squared Errors (sum_squared_errors): It calculates the sum of the squared differences between the predicted and actual values. It provides an overall measure of the model's performance.\nMean Squared Error (mean_squared_errors): It calculates the average of the squared differences between the predicted and actual values. It is widely used as a loss function in regression problems.\nRoot Mean Squared Error (root_mean_squared_errors): It is the square root of the mean squared error. It provides a measure of the average magnitude of the errors in the original scale of the target variable.\nMean of True Values (y_true_mean): It calculates the average of the actual values in the target variable. It can be useful for establishing a baseline for the model's performance.\nMean of Predicted Values (y_pred_mean): It calculates the average of the predicted values. It can be compared with the y_true_mean to get an idea of the model's bias.\nResidual Histograms (residual_hists): It represents the distribution of the differences between the predicted and actual values. It helps to understand the spread and pattern of the errors.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "bucket_size",
          "desc": "Number of buckets for residual histogram.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "10000"
            },
            "upperBoundInclusive": true
          }
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input table with prediction and label, usually is a result from a prediction component.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "label",
              "desc": "The label name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "prediction",
              "desc": "The prediction result column name to use in the dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "reports",
          "desc": "Output report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.eval",
      "name": "ss_pvalue",
      "desc": "Calculate P-Value for LR model training on vertical partitioning dataset by using secret sharing.\nFor large dataset(large than 10w samples & 200 features),\nrecommend to use [Ring size: 128, Fxp: 40] options for SPU device.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "model",
          "desc": "Input model.",
          "types": [
            "sf.model.ss_sgd",
            "sf.model.ss_glm"
          ]
        },
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output P-Value report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "sgb_predict",
      "desc": "Predict using SGB model.",
      "version": "0.0.3",
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          }
        },
        {
          "name": "pred_name",
          "desc": "Name for prediction column",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          }
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "model",
          "desc": "model",
          "types": [
            "sf.model.sgb"
          ]
        },
        {
          "name": "feature_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "pred",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ]
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "slnn_predict",
      "desc": "Predict using the SLNN model.\nThis component is not enabled by default, it requires the use of the full version\nof secretflow image and setting the ENABLE_NN environment variable to true.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "batch_size",
          "desc": "The number of examples per batch.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "8192"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          }
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          }
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "model",
          "desc": "Input model.",
          "types": [
            "sf.model.sl_nn"
          ]
        },
        {
          "name": "feature_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "pred",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ]
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "ss_glm_predict",
      "desc": "Predict using the SSGLM model.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          }
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          }
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "model",
          "desc": "Input model.",
          "types": [
            "sf.model.ss_glm"
          ]
        },
        {
          "name": "feature_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "pred",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ]
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "ss_sgd_predict",
      "desc": "Predict using the SS-SGD model.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "batch_size",
          "desc": "The number of training examples utilized in one iteration.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          }
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          }
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "model",
          "desc": "Input model.",
          "types": [
            "sf.model.ss_sgd"
          ]
        },
        {
          "name": "feature_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "pred",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ]
        }
      ]
    },
    {
      "domain": "ml.predict",
      "name": "ss_xgb_predict",
      "desc": "Predict using the SS-XGB model.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "receiver",
          "desc": "Party of receiver.",
          "type": "AT_PARTY",
          "atomic": {
            "listMinLengthInclusive": "1",
            "listMaxLengthInclusive": "1"
          }
        },
        {
          "name": "pred_name",
          "desc": "Column name for predictions.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pred"
            }
          }
        },
        {
          "name": "save_ids",
          "desc": "Whether to save ids columns into output prediction table. If true, input feature_dataset must contain id columns, and receiver party must be id owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        },
        {
          "name": "save_label",
          "desc": "Whether or not to save real label columns into output pred file. If true, input feature_dataset must contain label columns and receiver party must be label owner.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "model",
          "desc": "Input model.",
          "types": [
            "sf.model.ss_xgb"
          ]
        },
        {
          "name": "feature_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "saved_features",
              "desc": "which features should be saved with prediction result"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "pred",
          "desc": "Output prediction.",
          "types": [
            "sf.table.individual"
          ]
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "sgb_train",
      "desc": "Provides both classification and regression tree boosting (also known as GBDT, GBM)\nfor vertical split dataset setting by using secure boost.\n- SGB is short for SecureBoost. Compared to its safer counterpart SS-XGB, SecureBoost focused on protecting label holder.\n- Check https://arxiv.org/abs/1901.08755.",
      "version": "0.0.4",
      "attrs": [
        {
          "name": "num_boost_round",
          "desc": "Number of boosting iterations.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "max_depth",
          "desc": "Maximum depth of a tree.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "5"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "16"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "learning_rate",
          "desc": "Step size shrinkage used in update to prevent overfitting.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "objective",
          "desc": "Specify the learning objective.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "logistic"
            },
            "allowedValues": {
              "ss": [
                "linear",
                "logistic",
                "tweedie"
              ]
            }
          }
        },
        {
          "name": "reg_lambda",
          "desc": "L2 regularization term on weights.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "gamma",
          "desc": "Greater than 0 means pre-pruning enabled. If gain of a node is less than this value, it would be pruned.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "colsample_by_tree",
          "desc": "Subsample ratio of columns when constructing each tree.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "sketch_eps",
          "desc": "This roughly translates into O(1 / sketch_eps) number of bins.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "base_score",
          "desc": "The initial prediction score of all instances, global bias.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {
              "f": -10.0
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "seed",
          "desc": "Pseudorandom number generator seed.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "42"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "fixed_point_parameter",
          "desc": "Any floating point number encoded by heu, will multiply a scale and take the round, scale = 2 ** fixed_point_parameter. larger value may mean more numerical accuracy, but too large will lead to overflow problem.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "20"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "100"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "first_tree_with_label_holder_feature",
          "desc": "Whether to train the first tree with label holder's own features.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "batch_encoding_enabled",
          "desc": "If use batch encoding optimization.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        },
        {
          "name": "enable_quantization",
          "desc": "Whether enable quantization of g and h.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "quantization_scale",
          "desc": "Scale the sum of g to the specified value.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 10000.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000000.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "max_leaf",
          "desc": "Maximum leaf of a tree. Only effective if train leaf wise.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "15"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "32768"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "rowsample_by_tree",
          "desc": "Row sub sample ratio of the training instances.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "enable_goss",
          "desc": "Whether to enable GOSS.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "top_rate",
          "desc": "GOSS-specific parameter. The fraction of large gradients to sample.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.3
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "bottom_rate",
          "desc": "GOSS-specific parameter. The fraction of small gradients to sample.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.5
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "tree_growing_method",
          "desc": "How to grow tree?",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "level"
            }
          }
        },
        {
          "name": "enable_early_stop",
          "desc": "Whether to enable early stop during training.",
<<<<<<< HEAD
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "enable_monitor",
          "desc": "Whether to enable monitoring performance during training.",
=======
>>>>>>> 95547ade7047df593ec6bd1b61845f69527078a9
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "enable_monitor",
          "desc": "Whether to enable monitoring performance during training.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "eval_metric",
          "desc": "Use what metric for monitoring and early stop? Currently support ['roc_auc', 'rmse', 'mse', 'tweedie_deviance', 'tweedie_nll']",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "roc_auc"
            },
            "allowedValues": {
              "ss": [
                "roc_auc",
                "rmse",
                "mse",
                "tweedie_deviance",
                "tweedie_nll"
              ]
            }
          }
        },
        {
          "name": "validation_fraction",
          "desc": "Early stop specific parameter. Only effective if early stop enabled. The fraction of samples to use as validation set.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "stopping_rounds",
          "desc": "Early stop specific parameter. If more than 'stopping_rounds' consecutive rounds without improvement, training will stop. Only effective if early stop enabled",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "1024"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "stopping_tolerance",
          "desc": "Early stop specific parameter. If metric on validation set is no longer improving by at least this amount, then consider not improving.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "tweedie_variance_power",
          "desc": "Parameter that controls the variance of the Tweedie distribution.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.5
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "f": 1.0
            },
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 2.0
            }
          }
        },
        {
          "name": "save_best_model",
          "desc": "Whether to save the best model on validation set during training.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "train_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.sgb"
          ]
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "slnn_train",
      "desc": "Train nn models for vertical partitioning dataset by split learning.\nThis component is not enabled by default, it requires the use of the full version\nof secretflow image and setting the ENABLE_NN environment variable to true.\nSince it is necessary to define the model structure using python code,\nalthough the range of syntax and APIs that can be used has been restricted,\nthere are still potential security risks. It is recommended to use it in\nconjunction with process sandboxes such as nsjail.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "models",
          "desc": "Define the models for training.",
          "type": "AT_STRING",
          "atomic": {
            "defaultValue": {
              "s": "# pre imported:\n# import tensorflow as tf\n# from tensorflow import Module, keras\n# from tensorflow.keras import Model, layers\n# from tensorflow.keras.layers import Layer\n# from secretflow.ml.nn import applications as apps\n\ndef create_base_model(input_dim, output_dim):\n    model = keras.Sequential(\n        [\n            keras.Input(shape=input_dim),\n            layers.Dense(100, activation=\"relu\"),\n            layers.Dense(output_dim, activation=\"relu\"),\n        ]\n    )\n    return model\n\ndef create_fuse_model(input_dim):\n    input_layers = [keras.Input(input_dim), keras.Input(input_dim)]\n    merged_layer = layers.concatenate(input_layers)\n    fuse_layer = layers.Dense(64, activation='relu')(merged_layer)\n    output = layers.Dense(1, activation='sigmoid')(fuse_layer)\n    return keras.Model(inputs=input_layers, outputs=output)\n\nhidden_size = 64\n\nfit(\n    client_base=create_base_model(12, hidden_size),\n    server_base=create_base_model(4, hidden_size),\n    server_fuse=create_fuse_model(hidden_size),\n)\n"
            }
          }
        },
        {
          "name": "epochs",
          "desc": "The number of complete pass through the training data.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "learning_rate",
          "desc": "The step size at each iteration in one iteration.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.001
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "batch_size",
          "desc": "The number of training examples utilized in one iteration.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "512"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "validattion_prop",
          "desc": "The proportion of validation set to total data set.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "loss",
          "desc": "Loss function.",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "builtin"
          }
        },
        {
          "prefixes": [
            "loss"
          ],
          "name": "builtin",
          "desc": "Builtin loss function.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "mean_squared_error"
            },
            "allowedValues": {
              "ss": [
                "binary_crossentropy",
                "categorical_crossentropy",
                "mean_squared_error",
                "mean_squared_logarithmic_error",
                "mean_absolute_error",
                "mean_absolute_percentage_error",
                "cosine_similarity",
                "huber",
                "kl_divergence",
                "log_cosh",
                "poisson",
                "binary_focal_crossentropy",
                "sparse_categorical_crossentropy",
                "hinge",
                "categorical_hinge",
                "squared_hinge"
              ]
            }
          }
        },
        {
          "prefixes": [
            "loss"
          ],
          "name": "custom",
          "desc": "Custom loss function.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "def loss(y_true, y_pred):\n    return tf.keras.losses.mean_squared_error(y_true, y_pred)\n\n\ncompile_loss(loss)\n\n"
            }
          }
        },
        {
          "name": "optimizer",
          "desc": "Optimizer.",
          "type": "AT_STRUCT_GROUP"
        },
        {
          "prefixes": [
            "optimizer"
          ],
          "name": "name",
          "desc": "Optimizer name.",
          "type": "AT_STRING",
          "atomic": {
            "defaultValue": {
              "s": "Adam"
            },
            "allowedValues": {
              "ss": [
                "Adam",
                "SGD",
                "RMSprop",
                "AdamW",
                "Adamax",
                "Nadam",
                "Adagrad",
                "Adadelta",
                "Adafactor",
                "Ftrl",
                "Lion"
              ]
            }
          }
        },
        {
          "prefixes": [
            "optimizer"
          ],
          "name": "params",
          "desc": "Additional optimizer parameters in JSON format.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "metrics",
          "desc": "Metrics.",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "10",
            "isOptional": true,
            "defaultValue": {
              "ss": [
                "AUC"
              ]
            },
            "allowedValues": {
              "ss": [
                "AUC",
                "Accuracy",
                "Precision",
                "Recall",
                "BinaryAccuracy",
                "BinaryCrossentropy",
                "CategoricalAccuracy",
                "CategoricalCrossentropy",
                "CosineSimilarity",
                "FalseNegatives",
                "FalsePositives",
                "TrueNegatives",
                "TruePositives",
                "KLDivergence",
                "LogCoshError",
                "MeanAbsoluteError",
                "MeanAbsolutePercentageError",
                "MeanRelativeError",
                "MeanSquaredError",
                "MeanSquaredLogarithmicError",
                "Hinge",
                "SquaredHinge",
                "CategoricalHinge",
                "BinaryIoU",
                "IoU",
                "MeanIoU",
                "OneHotIoU",
                "OneHotMeanIoU",
                "Poisson",
                "PrecisionAtRecall",
                "RecallAtPrecision",
                "RootMeanSquaredError",
                "SensitivityAtSpecificity",
                "SparseCategoricalAccuracy",
                "SparseCategoricalCrossentropy",
                "SparseTopKCategoricalAccuracy",
                "SpecificityAtSensitivity",
                "TopKCategoricalAccuracy"
              ]
            }
          }
        },
        {
          "name": "model_input_scheme",
          "desc": "Input scheme of base model, tensor: merge all features into one tensor; tensor_dict: each feature as a tensor.",
          "type": "AT_STRING",
          "atomic": {
            "defaultValue": {
              "s": "tensor"
            },
            "allowedValues": {
              "ss": [
                "tensor",
                "tensor_dict"
              ]
            }
          }
        },
        {
          "name": "strategy",
          "desc": "Split learning strategy.",
          "type": "AT_STRUCT_GROUP"
        },
        {
          "prefixes": [
            "strategy"
          ],
          "name": "name",
          "desc": "Split learning strategy name.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "pipeline"
            },
            "allowedValues": {
              "ss": [
                "pipeline",
                "split_nn",
                "split_async",
                "split_state_async"
              ]
            }
          }
        },
        {
          "prefixes": [
            "strategy"
          ],
          "name": "params",
          "desc": "Additional strategy parameters in JSON format.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "{\"pipeline_size\":2}"
            }
          }
        },
        {
          "name": "compressor",
          "desc": "Compressor for hiddens and gradients.",
          "type": "AT_STRUCT_GROUP"
        },
        {
          "prefixes": [
            "compressor"
          ],
          "name": "name",
          "desc": "Compressor name.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "allowedValues": {
              "ss": [
                "",
                "topk_sparse",
                "random_sparse",
                "stc_sparse",
                "scr_sparse",
                "quantized_fp",
                "quantized_lstm",
                "quantized_kmeans",
                "quantized_zeropoint",
                "mixed_compressor"
              ]
            }
          }
        },
        {
          "prefixes": [
            "compressor"
          ],
          "name": "params",
          "desc": "Additional compressor parameters in JSON format.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "train_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.sl_nn"
          ]
        },
        {
          "name": "reports",
          "desc": "Output report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "ss_glm_train",
      "desc": "generalized linear model (GLM) is a flexible generalization of ordinary linear regression.\nThe GLM generalizes linear regression by allowing the linear model to be related to the response\nvariable via a link function and by allowing the magnitude of the variance of each measurement to\nbe a function of its predicted value.",
      "version": "0.0.3",
      "attrs": [
        {
          "name": "epochs",
          "desc": "The number of complete pass through the training data.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "learning_rate",
          "desc": "The step size at each iteration in one iteration.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "batch_size",
          "desc": "The number of training examples utilized in one iteration.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "link_type",
          "desc": "link function type",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "Logit",
                "Log",
                "Reciprocal",
                "Identity"
              ]
            }
          }
        },
        {
          "name": "label_dist_type",
          "desc": "label distribution type",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "Bernoulli",
                "Poisson",
                "Gamma",
                "Tweedie"
              ]
            }
          }
        },
        {
          "name": "tweedie_power",
          "desc": "Tweedie distribution power parameter",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 2.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "dist_scale",
          "desc": "A guess value for distribution's scale",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 1.0
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "f": 1.0
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "iter_start_irls",
          "desc": "run a few rounds of IRLS training as the initialization of w, 0 disable",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "decay_epoch",
          "desc": "decay learning interval",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "decay_rate",
          "desc": "decay learning rate",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "optimizer",
          "desc": "which optimizer to use: IRLS(Iteratively Reweighted Least Squares) or SGD(Stochastic Gradient Descent)",
          "type": "AT_STRING",
          "atomic": {
            "allowedValues": {
              "ss": [
                "SGD",
                "IRLS"
              ]
            }
          }
        },
        {
          "name": "l2_lambda",
          "desc": "L2 regularization term",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "infeed_batch_size_limit",
          "desc": "size of a single block, default to 8w * 100. increase the size will increase memory cost, but may decrease running time. Suggested to be as large as possible. (too large leads to OOM)",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "8000000"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1000"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "8000000"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "fraction_of_validation_set",
          "desc": "fraction of training set to be used as the validation set. ineffective for 'weight' stopping_metric",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.2
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "random_state",
          "desc": "random state for validation split",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1212"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "stopping_metric",
          "desc": "use what metric as the condition for early stop? Must be one of ['deviance', 'MSE', 'RMSE', 'AUC', 'weight']. only logit link supports AUC metric (note that AUC is very, very expansive in MPC)",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "deviance"
            },
            "allowedValues": {
              "ss": [
                "deviance",
                "MSE",
                "RMSE",
                "AUC",
                "weight"
              ]
            }
          }
        },
        {
          "name": "stopping_rounds",
          "desc": "If the model is not improving for stopping_rounds, the training process will be stopped, for 'weight' stopping metric, stopping_rounds is fixed to be 1",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "100"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "stopping_tolerance",
          "desc": "the model is considered as not improving, if the metric is not improved by tolerance over best metric in history. If metric is 'weight' and tolerance == 0, then early stop is disabled.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.001
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "report_metric",
          "desc": "Whether to report the value of stopping metric. Only effective if early stop is enabled. If this option is set to true, metric will be revealed and logged.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "use_high_precision_exp",
          "desc": "If you do not know the details of this parameter, please do not modify this parameter! If this option is true, glm training and prediction will use a high-precision exp approx, but there will be a large performance drop. Otherwise, use high performance exp approx, There will be no significant difference in model performance. However, prediction bias may occur if the model is exported to an external system for use.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "exp_iters",
          "desc": "If you do not know the details of this parameter, please do not modify this parameter! Specify the number of iterations of exp taylor approx, Only takes effect when use_high_precision_exp is false. Increasing this value will improve the accuracy of exp approx, but will quickly degrade performance.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "8"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "4"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "32"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "report_weights",
          "desc": "If this option is set to true, model will be revealed and model details are visible to all parties",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "train_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "offset",
              "desc": "Specify a column to use as the offset",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "weight",
              "desc": "Specify a column to use for the observation weights",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.ss_glm"
          ]
        },
        {
          "name": "report",
          "desc": "If report_weights is true, report model details",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "ss_sgd_train",
      "desc": "Train both linear and logistic regression\nlinear models for vertical partitioning dataset with mini batch SGD training solver by using secret sharing.\n- SS-SGD is short for secret sharing SGD training.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "epochs",
          "desc": "The number of complete pass through the training data.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "learning_rate",
          "desc": "The step size at each iteration in one iteration.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "batch_size",
          "desc": "The number of training examples utilized in one iteration.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1024"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {}
          }
        },
        {
          "name": "sig_type",
          "desc": "Sigmoid approximation type.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "t1"
            },
            "allowedValues": {
              "ss": [
                "real",
                "t1",
                "t3",
                "t5",
                "df",
                "sr",
                "mix"
              ]
            }
          }
        },
        {
          "name": "reg_type",
          "desc": "Regression type",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "logistic"
            },
            "allowedValues": {
              "ss": [
                "linear",
                "logistic"
              ]
            }
          }
        },
        {
          "name": "penalty",
          "desc": "The penalty(aka regularization term) to be used.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "None"
            },
            "allowedValues": {
              "ss": [
                "None",
                "l1",
                "l2"
              ]
            }
          }
        },
        {
          "name": "l2_norm",
          "desc": "L2 regularization term.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.5
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "eps",
          "desc": "If the change rate of weights is less than this threshold, the model is considered to be converged, and the training stops early. 0 to disable.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.001
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "report_weights",
          "desc": "If this option is set to true, model will be revealed and model details are visible to all parties",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "train_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.ss_sgd"
          ]
        },
        {
          "name": "report",
          "desc": "If report_weights is true, report model details",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "ml.train",
      "name": "ss_xgb_train",
      "desc": "This method provides both classification and regression tree boosting (also known as GBDT, GBM)\nfor vertical partitioning dataset setting by using secret sharing.\n- SS-XGB is short for secret sharing XGB.\n- More details: https://arxiv.org/pdf/2005.08479.pdf",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "num_boost_round",
          "desc": "Number of boosting iterations.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true
          }
        },
        {
          "name": "max_depth",
          "desc": "Maximum depth of a tree.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "5"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "16"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "learning_rate",
          "desc": "Step size shrinkage used in updates to prevent overfitting.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "objective",
          "desc": "Specify the learning objective.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "logistic"
            },
            "allowedValues": {
              "ss": [
                "linear",
                "logistic"
              ]
            }
          }
        },
        {
          "name": "reg_lambda",
          "desc": "L2 regularization term on weights.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10000.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "subsample",
          "desc": "Subsample ratio of the training instances.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "colsample_by_tree",
          "desc": "Subsample ratio of columns when constructing each tree.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "sketch_eps",
          "desc": "This roughly translates into O(1 / sketch_eps) number of bins.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "f": 0.1
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "base_score",
          "desc": "The initial prediction score of all instances, global bias.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {
              "f": -10.0
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 10.0
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "seed",
          "desc": "Pseudorandom number generator seed.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "42"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true
          }
        }
      ],
      "inputs": [
        {
          "name": "train_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be used for training.",
              "colMinCntInclusive": "1"
            },
            {
              "name": "label",
              "desc": "Label of train dataset.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_model",
          "desc": "Output model.",
          "types": [
            "sf.model.ss_xgb"
          ]
        }
      ]
    },
    {
      "domain": "model",
      "name": "model_export",
      "desc": "The model_export component supports converting and packaging the rule files generated by preprocessing and postprocessing components, as well as the model files generated by model operators, into a Secretflow-Serving model package. The list of components to be exported must contain exactly one model train or model predict component, and may include zero or multiple preprocessing and postprocessing components.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "model_name",
          "desc": "model's name",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "model_desc",
          "desc": "Describe what the model does",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "input_datasets",
          "desc": "The input data IDs for all components to be exported. Their order must remain consistent with the sequence in which the components were executed.",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "-1"
          }
        },
        {
          "name": "output_datasets",
          "desc": "The output data IDs for all components to be exported. Their order must remain consistent with the sequence in which the components were executed.",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "-1"
          }
        },
        {
          "name": "component_eval_params",
          "desc": "The eval parameters (in JSON format) for all components to be exported. Their order must remain consistent with the sequence in which the components were executed.",
          "type": "AT_STRINGS",
          "atomic": {
            "listMaxLengthInclusive": "-1"
          }
        }
      ],
      "outputs": [
        {
          "name": "package_output",
          "desc": "output tar package uri",
          "types": [
            "sf.serving.model"
          ]
        },
        {
          "name": "report",
          "desc": "report dumped model's input schemas",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "postprocessing",
      "name": "score_card_transformer",
      "desc": "Transform the predicted result (a probability value) produced by the logistic regression model into a more understandable score (for example, a score of up to 1000 points)",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "positive",
          "desc": "Value for positive cases.",
          "type": "AT_INT",
          "atomic": {
            "defaultValue": {
              "i64": "1"
            },
            "allowedValues": {
              "i64s": [
                "0",
                "1"
              ]
            }
          }
        },
        {
          "name": "predict_score_name",
          "type": "AT_STRING",
          "atomic": {
            "defaultValue": {
              "s": "predict_score"
            }
          }
        },
        {
          "name": "scaled_value",
          "desc": "Set a benchmark score that can be adjusted for specific business scenarios",
          "type": "AT_INT",
          "atomic": {
            "defaultValue": {
              "i64": "600"
            }
          }
        },
        {
          "name": "odd_base",
          "desc": "the odds value at given score baseline, odds = p / (1-p)",
          "type": "AT_FLOAT",
          "atomic": {
            "defaultValue": {
              "f": 20.0
            }
          }
        },
        {
          "name": "pdo",
          "desc": "points to double the odds",
          "type": "AT_FLOAT",
          "atomic": {
            "defaultValue": {
              "f": 20.0
            }
          }
        },
        {
          "name": "min_score",
          "desc": "An integer of [0,999] is supported",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "999"
            },
            "upperBoundInclusive": true
          }
        },
        {
          "name": "max_score",
          "desc": "An integer of [1,1000] is supported",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "1000"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {
              "i64": "1"
            },
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "1000"
            },
            "upperBoundInclusive": true
          }
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "predict result table",
          "types": [
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "predict_name",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "output table",
          "types": [
            "sf.table.individual"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "binary_op",
      "desc": "Perform binary operation binary_op(f1, f2) and assign the result to f3, f3 can be new or old. Currently f1, f2 and f3 all belong to a single party.",
      "version": "0.0.2",
      "attrs": [
        {
          "name": "binary_op",
          "desc": "What kind of binary operation we want to do, currently only supports +, -, *, /",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "+"
            },
            "allowedValues": {
              "ss": [
                "+",
                "-",
                "*",
                "/"
              ]
            }
          }
        },
        {
          "name": "new_feature_name",
          "desc": "Name of the newly generated feature.",
          "type": "AT_STRING",
          "atomic": {}
        },
        {
          "name": "as_label",
          "desc": "If True, the generated feature will be marked as label in schema.",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "f1",
              "desc": "Feature 1 to operate on.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            },
            {
              "name": "f2",
              "desc": "Feature 2 to operate on.",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "out_ds",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_rules",
          "desc": "feature gen rule",
          "types": [
            "sf.rule.preprocessing"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "case_when",
      "desc": "case_when",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "rules",
          "desc": "input CaseWhen rules",
          "type": "AT_CUSTOM_PROTOBUF",
          "customProtobufCls": "case_when_rules_pb2.CaseWhenRule"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_dataset",
          "desc": "output_dataset",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_rules",
          "desc": "case when substitution rule",
          "types": [
            "sf.rule.preprocessing"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "cast",
      "desc": "For conversion between basic data types, such as converting float to string.",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "astype",
          "desc": "single-choice, options available are string, integer, float",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "integer"
          }
        },
        {
          "prefixes": [
            "astype"
          ],
          "name": "integer",
          "desc": "integer"
        },
        {
          "prefixes": [
            "astype"
          ],
          "name": "float",
          "desc": "float"
        },
        {
          "prefixes": [
            "astype"
          ],
          "name": "string",
          "desc": "string"
        }
      ],
      "inputs": [
        {
          "name": "input_ds",
          "desc": "The input table",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "columns",
              "desc": "Multiple-choice, options available are string, integer, float, boolean",
              "colMinCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_ds",
          "desc": "The output table",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "output_rules",
          "desc": "The output rules",
          "types": [
            "sf.rule.preprocessing"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "feature_calculate",
      "desc": "Generate a new feature by performing calculations on an origin feature",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "rules",
          "desc": "input CalculateOpRules rules",
          "type": "AT_CUSTOM_PROTOBUF",
          "customProtobufCls": "calculate_rules_pb2.CalculateOpRules"
        }
      ],
      "inputs": [
        {
          "name": "in_ds",
          "desc": "Input vertical table",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "features",
              "desc": "Feature(s) to operate on",
              "colMinCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "out_ds",
          "desc": "output_dataset",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_rules",
          "desc": "feature calculate rule",
          "types": [
            "sf.rule.preprocessing"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "fillna",
      "desc": "fillna",
      "version": "0.0.1",
      "attrs": [
        {
          "name": "strategy",
          "desc": "The imputation strategy. If \"mean\", then replace missing values using the mean along each column. Can only be used with numeric data. If \"median\", then replace missing values using the median along each column. Can only be used with numeric data. If \"most_frequent\", then replace missing using the most frequent value along each column. Can be used with strings or numeric data. If there is more than one such value, only the smallest is returned. If \"constant\", then replace missing values with fill_value. Can be used with strings or numeric data.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "constant"
            },
            "allowedValues": {
              "ss": [
                "mean",
                "median",
                "most_frequent",
                "constant"
              ]
            }
          }
        },
        {
          "name": "missing_value_type",
          "desc": "type of missing value. general_na type indicates that only np.nan, None or pandas.NA will be treated as missing values. When the type is not general_na, the type casted missing_value_type(missing_value) will also be treated as missing value as well, in addition to general_na values.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "general_na"
            },
            "allowedValues": {
              "ss": [
                "general_na",
                "str",
                "int",
                "float"
              ]
            }
          }
        },
        {
          "name": "missing_value",
          "desc": "Which value should be treat as missing_value? If missing value type is 'general_na', this field will be ignored, and any np.nan, pd.NA, etc value will be treated as missing value. Otherwise, the type casted missing_value_type(missing_value) will also be treated as missing value as well, in addition to general_na values. In case the cast is not successful, general_na will be used instead. default value is 'custom_missing_value'.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "s": "custom_missing_value"
            }
          }
        },
        {
          "name": "fill_value_int",
          "desc": "For int type data. If method is 'constant' use this value for filling null.",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "fill_value_float",
          "desc": "For float type data. If method is 'constant' use this value for filling null.",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        },
        {
          "name": "fill_value_str",
          "desc": "For str type data. If method is 'constant' use this value for filling null.",
          "type": "AT_STRING",
          "atomic": {
            "isOptional": true,
            "defaultValue": {}
          }
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "fill_na_features",
              "desc": "Features to fill."
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "out_ds",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_rules",
          "desc": "fill value rule",
          "types": [
            "sf.rule.preprocessing"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "onehot_encode",
      "desc": "onehot_encode",
      "version": "0.0.3",
      "attrs": [
        {
          "name": "drop",
          "desc": "drop unwanted category based on selection",
          "type": "AT_UNION_GROUP",
          "union": {
            "defaultSelection": "no_drop"
          }
        },
        {
          "prefixes": [
            "drop"
          ],
          "name": "no_drop",
          "desc": "do not drop"
        },
        {
          "prefixes": [
            "drop"
          ],
          "name": "first",
          "desc": "drop the first category in each feature."
        },
        {
          "prefixes": [
            "drop"
          ],
          "name": "mode",
          "desc": "drop the mode category in each feature"
        },
        {
          "name": "min_frequency",
          "desc": "Specifies the minimum frequency below which a category will be considered infrequent, [0, 1), 0 disable",
          "type": "AT_FLOAT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {},
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "lowerBoundInclusive": true,
            "upperBoundEnabled": true,
            "upperBound": {
              "f": 1.0
            }
          }
        },
        {
          "name": "report_rules",
          "desc": "Whether to report rule details",
          "type": "AT_BOOL",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "b": true
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ],
          "attrs": [
            {
              "name": "features",
              "desc": "Features to encode."
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_dataset",
          "desc": "output_dataset",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "out_rules",
          "desc": "onehot rule",
          "types": [
            "sf.rule.preprocessing"
          ]
        },
        {
          "name": "report",
          "desc": "report rules details if report_rules is true",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "substitution",
      "desc": "unified substitution component",
      "version": "0.0.2",
      "inputs": [
        {
          "name": "input_dataset",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "input_rules",
          "desc": "Input preprocessing rules",
          "types": [
            "sf.rule.preprocessing"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_dataset",
          "desc": "output_dataset",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "preprocessing",
      "name": "vert_bin_substitution",
      "desc": "Substitute datasets' value by bin substitution rules.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_data",
          "desc": "Vertical partitioning dataset to be substituted.",
          "types": [
            "sf.table.vertical_table"
          ]
        },
        {
          "name": "bin_rule",
          "desc": "Input bin substitution rule.",
          "types": [
            "sf.rule.binning"
          ]
        }
      ],
      "outputs": [
        {
          "name": "output_data",
          "desc": "Output vertical table.",
          "types": [
            "sf.table.vertical_table"
          ]
        }
      ]
    },
    {
      "domain": "stats",
      "name": "groupby_statistics",
      "desc": "Get a groupby of statistics, like pandas groupby statistics.\nCurrently only support VDataframe.",
      "version": "0.0.3",
      "attrs": [
        {
          "name": "aggregation_config",
          "desc": "input groupby aggregation config",
          "type": "AT_CUSTOM_PROTOBUF",
          "customProtobufCls": "groupby_aggregation_config_pb2.GroupbyAggregationConfig"
        },
        {
          "name": "max_group_size",
          "desc": "The maximum number of groups allowed",
          "type": "AT_INT",
          "atomic": {
            "isOptional": true,
            "defaultValue": {
              "i64": "10000"
            },
            "lowerBoundEnabled": true,
            "lowerBound": {},
            "upperBoundEnabled": true,
            "upperBound": {
              "i64": "10001"
            }
          }
        }
      ],
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input table.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "by",
              "desc": "by what columns should we group the values",
              "colMinCntInclusive": "1",
              "colMaxCntInclusive": "4"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output groupby statistics report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "stats",
      "name": "ss_pearsonr",
      "desc": "Calculate Pearson's product-moment correlation coefficient for vertical partitioning dataset\nby using secret sharing.\n- For large dataset(large than 10w samples & 200 features), recommend to use [Ring size: 128, Fxp: 40] options for SPU device.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "Specify which features to calculate correlation coefficient with. If empty, all features will be used"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output Pearson's product-moment correlation coefficient report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "stats",
      "name": "ss_vif",
      "desc": "Calculate Variance Inflation Factor(VIF) for vertical partitioning dataset\nby using secret sharing.\n- For large dataset(large than 10w samples & 200 features), recommend to use [Ring size: 128, Fxp: 40] options for SPU device.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input vertical table.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "Specify which features to calculate VIF with. If empty, all features will be used."
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output Variance Inflation Factor(VIF) report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "stats",
      "name": "stats_psi",
      "desc": "population stability index.",
      "version": "0.0.1",
      "inputs": [
        {
          "name": "input_base_data",
          "desc": "Input base vertical table.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "feature_selects",
              "desc": "which features should be binned.",
              "colMinCntInclusive": "1"
            }
          ]
        },
        {
          "name": "input_test_data",
          "desc": "Input test vertical table.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ]
        },
        {
          "name": "bin_rule",
          "desc": "Input bin rule.",
          "types": [
            "sf.rule.binning"
          ]
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output population stability index.",
          "types": [
            "sf.report"
          ]
        }
      ]
    },
    {
      "domain": "stats",
      "name": "table_statistics",
      "desc": "Get a table of statistics,\nincluding each column's\n1. datatype\n2. total_count\n3. count\n4. count_na\n5. na_ratio\n6. min\n7. max\n8. mean\n9. var\n10. std\n11. sem\n12. skewness\n13. kurtosis\n14. q1\n15. q2\n16. q3\n17. moment_2\n18. moment_3\n19. moment_4\n20. central_moment_2\n21. central_moment_3\n22. central_moment_4\n23. sum\n24. sum_2\n25. sum_3\n26. sum_4\n- moment_2 means E[X^2].\n- central_moment_2 means E[(X - mean(X))^2].\n- sum_2 means sum(X^2).",
      "version": "0.0.2",
      "inputs": [
        {
          "name": "input_data",
          "desc": "Input table.",
          "types": [
            "sf.table.vertical_table",
            "sf.table.individual"
          ],
          "attrs": [
            {
              "name": "features",
              "desc": "perform statistics on these columns",
              "colMinCntInclusive": "1"
            }
          ]
        }
      ],
      "outputs": [
        {
          "name": "report",
          "desc": "Output table statistics report.",
          "types": [
            "sf.report"
          ]
        }
      ]
    }
  ]
}